<!doctype html> <html lang="vi"> <head> <meta charset="utf-8" /> <title>Solar System — Full</title> <meta name="viewport" content="width=device-width,initial-scale=1" /> <style> html,body { height:100%; margin:0; background:#000; font-family: sans-serif; } #container { width:100%; height:100vh; overflow:hidden; } .info { position: absolute; left: 12px; top: 12px; z-index: 10; background: rgba(0,0,0,0.45); color: #fff; padding:8px 10px; border-radius:8px; font-size:13px; } .label { color: #fff; padding: 2px 6px; background: rgba(0,0,0,0.6); border-radius: 4px; font-size: 12px; white-space: nowrap; transform: translate(-50%,-50%); pointer-events: none; } </style> </head> <body> <div id="container"></div> <div class="info">Solar System — di chuột để xoay, cuộn để zoom. Bấm H để hi/ẩn quỹ đạo.</div> <script type="module"> import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js'; import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/controls/OrbitControls.js'; import { CSS2DRenderer, CSS2DObject } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/renderers/CSS2DRenderer.js'; import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/postprocessing/EffectComposer.js'; import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/postprocessing/RenderPass.js'; import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/postprocessing/UnrealBloomPass.js'; const container = document.getElementById('container'); const scene = new THREE.Scene(); // Camera + Renderer const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000); camera.position.set(0, 220, 700); const renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setPixelRatio(window.devicePixelRatio || 1); renderer.setSize(innerWidth, innerHeight); renderer.outputEncoding = THREE.sRGBEncoding; container.appendChild(renderer.domElement); // Label renderer (CSS) const labelRenderer = new CSS2DRenderer(); labelRenderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.domElement.style.position = 'absolute'; labelRenderer.domElement.style.top = '0'; labelRenderer.domElement.style.pointerEvents = 'none'; container.appendChild(labelRenderer.domElement); // Controls const controls = new OrbitControls(camera, labelRenderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.08; controls.minDistance = 80; controls.maxDistance = 2500; // Background: galaxy texture // (fallback color if texture fails) const loader = new THREE.TextureLoader(); loader.crossOrigin = ''; // allow cross-origin const bgURL = 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/skies/space3.png'; loader.load(bgURL, tex => { scene.background = tex; }, undefined, err => { scene.background = new THREE.Color(0x000011); } ); // Sun (emissive) + light const sunGeo = new THREE.SphereGeometry(40, 64, 64); // try to load sun texture (fallback to emissive color) const sunMat = new THREE.MeshStandardMaterial({ emissive: 0xff8833, emissiveIntensity: 1.2, roughness: 0.5 }); loader.load( 'https://raw.githubusercontent.com/thiagopnts/solar-system-textures/master/sun.jpg', tex => { sunMat.map = tex; sunMat.emissiveMap = tex; sunMat.needsUpdate = true; }, undefined, () => {} ); const sun = new THREE.Mesh(sunGeo, sunMat); scene.add(sun); // bloom / composer for glow const composer = new EffectComposer(renderer); composer.setSize(window.innerWidth, window.innerHeight); composer.addPass(new RenderPass(scene, camera)); const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.6, 0.1); bloomPass.threshold = 0.0; bloomPass.strength = 1.2; bloomPass.radius = 0.8; composer.addPass(bloomPass); // Point light from sun const sunLight = new THREE.PointLight(0xfff2cc, 2.6, 4000, 2); sunLight.position.copy(sun.position); scene.add(sunLight); // helper ambient const ambient = new THREE.AmbientLight(0x333344, 0.6); scene.add(ambient); // Planets data (name, size, distance, orbitSpeed, rotationSpeed, textureURL, ring info) const planetDefs = [ { name: 'Mercury', size: 4, dist: 70, orbitSpeed: 0.023, rotSpeed: 0.002, tex: null, color: 0x888888 }, { name: 'Venus', size: 7, dist: 100, orbitSpeed: 0.017, rotSpeed: 0.001, tex: 'https://raw.githubusercontent.com/ajay2507/planet-textures/main/venus.jpg', color: 0xffd7a8 }, { name: 'Earth', size: 8.5, dist: 140, orbitSpeed: 0.013, rotSpeed: 0.02, tex: 'https://threejsfundamentals.org/threejs/resources/images/earth.jpg', color: 0x2a6ef0 }, { name: 'Mars', size: 6, dist: 175, orbitSpeed: 0.01, rotSpeed: 0.018, tex: 'https://raw.githubusercontent.com/ajay2507/planet-textures/main/mars.jpg', color: 0xff6b4a }, { name: 'Jupiter', size: 20, dist: 235, orbitSpeed: 0.006, rotSpeed: 0.04, tex: 'https://raw.githubusercontent.com/ajay2507/planet-textures/main/jupiter.jpg', color: 0xd9b37a }, { name: 'Saturn', size: 17, dist: 305, orbitSpeed: 0.004, rotSpeed: 0.038, tex: 'https://raw.githubusercontent.com/ajay2507/planet-textures/main/saturn.jpg', ring: { inner: 20, outer: 36, tex: 'https://raw.githubusercontent.com/ajay2507/planet-textures/main/saturn_ring.png' }, color: 0xe8d9b0 }, { name: 'Uranus', size: 11, dist: 360, orbitSpeed: 0.0026, rotSpeed: 0.03, tex: 'https://raw.githubusercontent.com/ajay2507/planet-textures/main/uranus.jpg', color: 0x9fe8f0 }, { name: 'Neptune', size: 11, dist: 420, orbitSpeed: 0.002, rotSpeed: 0.03, tex: 'https://raw.githubusercontent.com/ajay2507/planet-textures/main/neptune.jpg', color: 0x3b6ef0 }, ]; // container for planet objects const planets = []; // create orbit lines const orbitGroup = new THREE.Group(); scene.add(orbitGroup); function makeOrbit(radius) { const curve = new THREE.EllipseCurve(0,0, radius, radius, 0, Math.PI*2, false, 0); const points = curve.getPoints(128); const geometry = new THREE.BufferGeometry().setFromPoints(points.map(p=>new THREE.Vector3(p.x,0,p.y))); const mat = new THREE.LineBasicMaterial({ color: 0x666666, transparent:true, opacity:0.35 }); const line = new THREE.LineLoop(geometry, mat); line.rotation.x = Math.PI/2; return line; } // Create planets with pivot objects for orbit planetDefs.forEach(def => { const pivot = new THREE.Object3D(); pivot.userData = { orbitSpeed: def.orbitSpeed }; scene.add(pivot); // geometry & material const geometry = new THREE.SphereGeometry(def.size, 48, 48); const mat = new THREE.MeshStandardMaterial({ color: def.color, roughness: 0.7, metalness: 0.0 }); // try to load texture if provided; fallback to color if (def.tex) { loader.load(def.tex, tex => { tex.encoding = THREE.sRGBEncoding; mat.map = tex; mat.needsUpdate = true; }, undefined, err => { /* ignore, color will be used */ } ); } const mesh = new THREE.Mesh(geometry, mat); mesh.position.set(def.dist, 0, 0); pivot.add(mesh); // add subtle shadow / rim: use a sprite or emissive map? We'll add slight emissive color mesh.material.emissive = new THREE.Color(0x000000); mesh.material.emissiveIntensity = 0.01; // add CSS label const div = document.createElement('div'); div.className = 'label'; div.textContent = def.name; const label = new CSS2DObject(div); label.position.set(def.dist, def.size + 8, 0); pivot.add(label); // Saturn ring if (def.ring) { const ringGeo = new THREE.RingGeometry(def.ring.inner, def.ring.outer, 64); const ringMat = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent: true, opacity: 0.95 }); if (def.ring.tex) { loader.load(def.ring.tex, t => { ringMat.map = t; ringMat.needsUpdate = true; }, undefined, ()=>{}); } else { ringMat.color = new THREE.Color(0x9b8169); } const ringMesh = new THREE.Mesh(ringGeo, ringMat); // orient ring slightly tilted ringMesh.rotation.x = Math.PI / 2.8; ringMesh.position.set(def.dist, 0, 0); pivot.add(ringMesh); } // orbit line const orbitLine = makeOrbit(def.dist); orbitGroup.add(orbitLine); planets.push({ def, pivot, mesh }); }); // small moon for Earth const moonGeo = new THREE.SphereGeometry(2.2, 32, 32); const moonMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa }); const moon = new THREE.Mesh(moonGeo, moonMat); const earthObj = planets.find(p=>p.def.name === 'Earth'); if (earthObj) { const moonPivot = new THREE.Object3D(); moonPivot.position.copy(earthObj.mesh.position); moon.position.set(14, 0, 0); moonPivot.add(moon); scene.add(moonPivot); earthObj.moonPivot = moonPivot; } // starfield (particles) function makeStarfield(count=2000, radius=1800) { const geom = new THREE.BufferGeometry(); const positions = new Float32Array(count*3); for (let i=0;i<count;i++){ const r = radius * (0.6 + Math.random()*0.4); const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2*Math.random()-1); const x = r * Math.sin(phi) * Math.cos(theta); const y = r * Math.sin(phi) * Math.sin(theta); const z = r * Math.cos(phi); positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z; } geom.setAttribute('position', new THREE.BufferAttribute(positions, 3)); const mat = new THREE.PointsMaterial({ size: 1.4, sizeAttenuation: true, color: 0xFFFFFF, transparent: true, opacity: 0.9 }); const pts = new THREE.Points(geom, mat); scene.add(pts); } makeStarfield(); // Toggle orbits visibility let showOrbits = true; window.addEventListener('keydown', (e)=>{ if (e.key.toLowerCase() === 'h') { showOrbits = !showOrbits; orbitGroup.visible = showOrbits; } }); // animation loop let time = 0; function animate() { requestAnimationFrame(animate); const dt = 0.016; // ~60fps timestep time += dt; // rotate sun slowly and add subtle emissive flicker sun.rotation.y += 0.0012; sun.material.emissiveIntensity = 1.0 + Math.sin(time*1.7)*0.05; // animate planets: orbit pivot rotates, planets rotate on axis planets.forEach(p => { p.pivot.rotation.y += p.def.orbitSpeed * 0.6; // orbit around sun p.mesh.rotation.y += p.def.rotSpeed; // spin on axis // if earth, update moon pivot around earth if (p.def.name === 'Earth' && earthObj && earthObj.moonPivot) { // position moonPivot at earth's world position const worldPos = new THREE.Vector3(); p.mesh.getWorldPosition(worldPos); earthObj.moonPivot.position.copy(worldPos); earthObj.moonPivot.rotation.y += 0.04; // moon orbit speed } }); controls.update(); composer.render(); labelRenderer.render(scene, camera); } animate(); // responsive window.addEventListener('resize', () => { camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight); labelRenderer.setSize(innerWidth, innerHeight); }); // small UI: click on planet to focus camera smoothly renderer.domElement.addEventListener('dblclick', (ev) => { ev.preventDefault(); // compute mouse pos const rect = renderer.domElement.getBoundingClientRect(); const mx = ( (ev.clientX - rect.left) / rect.width ) * 2 - 1; const my = - ( (ev.clientY - rect.top) / rect.height ) * 2 + 1; const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(new THREE.Vector2(mx,my), camera); const intersects = raycaster.intersectObjects(planets.map(p=>p.mesh), true); if (intersects.length>0) { const target = intersects[0].object; // get world pos const pos = new THREE.Vector3(); target.getWorldPosition(pos); // animate camera to target (simple lerp) const startPos = camera.position.clone(); const startTarget = controls.target.clone(); const endPos = pos.clone().add(new THREE.Vector3(0, 40 + target.geometry.parameters.radius*3, target.geometry.parameters.radius*8)); let progress = 0; const dur = 700; // ms const t0 = performance.now(); function step() { const now = performance.now(); progress = Math.min(1, (now - t0) / dur); camera.position.lerpVectors(startPos, endPos, smoothstep(progress)); controls.target.lerpVectors(startTarget, pos, smoothstep(progress)); if (progress < 1) requestAnimationFrame(step); } step(); } }); function smoothstep(x){ return x*x*(3-2*x); } // Optional: UI to toggle labels (not shown), etc. // End of module </script> </body> </html>
